## original code by Derek Vidovic# modified by rich simpson# v1.1from turtle import *from random import *# Coordinates:# (0, 0) is the cell in the lower left corner of the maze# x increases to the right; y increases up# directions of travel (in degrees) for the turtleEAST = 0        # head towards right of screenNORTH = 90      # head towards top of screenWEST = 180      # head towards left of screenSOUTH = 270     # head towards bottom of screenclass Cell:    # size (in pixels) of one side of grid cell    SIDE = 20        def __init__(self, _r, _c, _grid):        """        Create a grid cell in position r, c        (0, 0) is lower left corner of maze        """        self.c = _c        self.r = _r        self.grid = _grid    def drawLine(self, _turtle, _orientation, _pos):        """        Draw a single side of the cell        """        # move turtle to lower left corner        _turtle.goto(_pos[0], _pos[1])        # orient turtle towards right side of screen        _turtle.setheading(_orientation)        # start drawing        _turtle.pendown()        # move turtle the length of the side of the cell        _turtle.fd(Cell.SIDE)        # stop drawing        _turtle.penup()    def draw(self, _turtle):        """        draw the cell with the provided Turtle        only draws south and west walls of each cell; other cells will do north and east        (unless this is a top or right cell)        """        # get lower-left corner of cell (in pixels)        lowerLeft = self.getLowerLeftCorner()        # get upper-right corner of cell (in pixels)        upperRight = self.getUpperRightCorner()        # if the cell's south wall exists, draw it in        if self.grid.horizontals[self.r][self.c]:            self.drawLine(_turtle, EAST, lowerLeft)        # if the cell's west wall exists, draw it in        if self.grid.verticals[self.r][self.c]:            self.drawLine(_turtle, NORTH, lowerLeft)        # are we at the top row of the maze?        if self.r + 1 == self.grid.height:            # draw in the top of the maze            self.drawLine(_turtle, WEST, upperRight)        # are we on the last (right-most) column of the maze?        if self.c + 1 == self.grid.width:            # draw in the right border of the maze            self.drawLine(_turtle, SOUTH, upperRight)    def cellWalls(self):        """        Returns a tuple with four elements indicating whether the cell has a north, east, south or west wall.        If a cell has a wall on all four sides:         -        | |  -> (True, True, True ,True)         _        If a cell has a wall on its north and west sides:         -        |    -> (True, False, False, True)        If a cell has a wall on its north, south and east sides:         -          |  -> (True, True, True, False)         _        """        return (            self.grid.horizontals[self.r+1][self.c],    # north            self.grid.verticals[self.r][self.c+1],      # east            self.grid.horizontals[self.r][self.c],      # south            self.grid.verticals[self.r][self.c]         # west        )    def getLowerLeftCorner(self):        """        Return a tuple with the (x, y) coordinates of the lower-left corner of the cell in pixels        """        return (Cell.SIDE * (self.c - self.grid.halfWidth() - 1/2),                Cell.SIDE * (self.r - self.grid.halfHeight() - 1/2))    def getUpperRightCorner(self):        """        Return a tuple with the (x, y) coordinates of the upper-right corner of the cell in pixels        """        pos = self.getLowerLeftCorner()        return (pos[0] + Cell.SIDE, pos[1] + Cell.SIDE)class Grid:    """    The grid consists of cells in rows and columns. The zero row and zero column are in the    lower left corner.    """    def __init__(self, _width, _height):        # create the "turtle" that will draw the maze        self.turtle = Turtle()        # set the turtle's speed        self.turtle.speed(0)        # keep track of turtle's location - starts in lower left corner        self.turtlePos = (0, 0)        # number of columns in maze        self.width = _width        # number of rows in maze        self.height = _height        #array of arrays: [r][c], going up and right        self.cells = []        # for every row...        for r in range(_height):            # create an empty list            self.cells.append([])            # for every column in the row...            for c in range(_width):                # add a new cell object                self.cells[r].append(Cell(r, c, _grid=self))        # verticals[r][c] is the west wall of cell at (x=c, y=r)        self.verticals = []        # horizontals[r][c] is the south wall of cell at (x=c, y=r)        self.horizontals = []        # for each row...        for r in range(_height + 1):            # create an empty list for west walls...            self.verticals.append([])            # and south walls            self.horizontals.append([])            # for each column...            for c in range(_width + 1):                # start out assuming there is no west wall...                self.verticals[r].append(False)                # or south wall                self.horizontals[r].append(False)    def halfWidth(self):        # return the middle column of the maze        return self.width / 2    def halfHeight(self):        # return the middle row of the maze        return self.height / 2    def draw(self):        """        (re)draw the entire grid with the provided Turtle        """        # make sure we aren't drawing (yet)        self.turtle.penup()        # for each row...        for row in self.cells:            # and each column            for cell in row:                # draw the west and south walls of the cell (if they exist)                cell.draw(self.turtle)    def randomizeWalls(self, _wallChance):        """        Randomly choose whether a cell has a west or south wall        """        # for each row...        for r in range(len(self.verticals)):            # and ech column...            for c in range(len(self.verticals[r])):                # does the cell have a west wall?                self.verticals[r][c] = random() < _wallChance                # does the cell have a south wall?                self.horizontals[r][c] = random() < _wallChance    def putExteriorWalls(self, _wallsOn=True):        """        sets all exterior walls to wallsOn        call this with True to make the maze completely enclosed        """        # set the east and west borders of the maze        for r in range(len(self.verticals)):            # west/left border            self.verticals[r][0] = _wallsOn            # east/right border            self.verticals[r][len(self.verticals[r]) - 1] = _wallsOn        # set the north and south borders of the maze        for c in range(len(self.horizontals[0])):            # south/bottom border            self.horizontals[0][c] = _wallsOn            # north/top border            self.horizontals[len(self.horizontals) - 1][c] = _wallsOn    def putTurtleInCell(self, _row, _col):        """        Moves the turtle to the center of the cell at the given row and column        """        # make sure we aren't drawing        self.turtle.penup()        # get a pointer to the cell        cell = self.cells[_row][_col]        # get the lower left corner of the cell        lowerLeft = cell.getLowerLeftCorner()        # get the center of the cell        center = (lowerLeft[0] + (Cell.SIDE / 2), lowerLeft[1] + (Cell.SIDE / 2))        # reposition turtle to center of cell        self.turtle.goto(center[0], center[1])        # keep track of turtle's location        self.turtlePos = (_row, _col)    def moveTurtleToCell(self, _to):        """        Moves turtle between two adjacent cells and draws a line to show movement        The _to argument is a direction ('north', 'south', 'east', 'west')        """        # make sure we aren't drawing        self.turtle.penup()        if ((_to == 'west' or _to == 'West' or _to == 'WEST') and (self.turtlePos[1] > 0)):            # orient the turtle correctly            self.turtle.setheading(WEST)            # update the turtle's location            self.turtlePos = (self.turtlePos[0], self.turtlePos[1] - 1)        # to cell is to the right of the from cell        elif ((_to == 'east' or _to == 'East' or _to == 'EAST') and (self.turtlePos[1] < self.width)):            # orient the turtle correctly (where is the to cell relative to the from cell?)            self.turtle.setheading(EAST)            # update the turtle's location            self.turtlePos = (self.turtlePos[0], self.turtlePos[1] + 1)        # to cell is above the from cell (to row is one more than from row, same column)        elif ((_to == 'north' or _to == 'North' or _to == 'NORTH') and (self.turtlePos[0] < self.height)):            # orient the turtle correctly (where is the to cell relative to the from cell?)            self.turtle.setheading(NORTH)            # update the turtle's location            self.turtlePos = (self.turtlePos[0] + 1, self.turtlePos[1])        # to cell is below the from cell        elif ((_to == 'south' or _to == 'South' or _to == 'SOUTH') and (self.turtlePos[0] > 0)):            # orient the turtle correctly (where is the to cell relative to the from cell?)            self.turtle.setheading(SOUTH)            # update the turtle's location            self.turtlePos = (self.turtlePos[0] - 1, self.turtlePos[1])        # if none of these are true, then we aren't in an adjacent cell        else:            return        # start drawing        self.turtle.pendown()        # move turtle the length of the side of the cell        self.turtle.fd(Cell.SIDE)        # stop drawing        self.turtle.penup()def create_maze():    # create an empty 28x28 grid    g = Grid(28,28)    # fill in walls randomly    g.randomizeWalls(0.25)    # put the exterior walls around the maze    g.putExteriorWalls()    # draw the maze    g.draw()    return g